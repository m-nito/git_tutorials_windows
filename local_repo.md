## `git` チュートリアル
- `git` は「コミット」と呼ばれる差分の単位でファイルの変更履歴を管理します。
- ここでは「ブランチ」などの発展的要素の説明をいったん省き、ローカル環境でリポジトリを作成、管理する方法を解説します。

## TOC
- [`git` リポジトリを作成する](#git-%e3%83%aa%e3%83%9d%e3%82%b8%e3%83%88%e3%83%aa%e3%82%92%e4%bd%9c%e6%88%90%e3%81%99%e3%82%8b)
- [`git` でファイルの管理を行う](#git-%e3%81%a7%e3%83%95%e3%82%a1%e3%82%a4%e3%83%ab%e3%81%ae%e7%ae%a1%e7%90%86%e3%82%92%e8%a1%8c%e3%81%86)
- [ファイルの変更をステージングする](#%e3%83%95%e3%82%a1%e3%82%a4%e3%83%ab%e3%81%ae%e5%a4%89%e6%9b%b4%e3%82%92%e3%82%b9%e3%83%86%e3%83%bc%e3%82%b8%e3%83%b3%e3%82%b0%e3%81%99%e3%82%8b)
- [`.gitignore` の追加](#gitignore-%e3%81%ae%e8%bf%bd%e5%8a%a0)
- [リポジトリにステージングされた変更をコミットする](#%e3%83%aa%e3%83%9d%e3%82%b8%e3%83%88%e3%83%aa%e3%81%ab%e3%82%b9%e3%83%86%e3%83%bc%e3%82%b8%e3%83%b3%e3%82%b0%e3%81%95%e3%82%8c%e3%81%9f%e5%a4%89%e6%9b%b4%e3%82%92%e3%82%b3%e3%83%9f%e3%83%83%e3%83%88%e3%81%99%e3%82%8b)
- [リポジトリを過去のコミット時点までリセットする](#%e3%83%aa%e3%83%9d%e3%82%b8%e3%83%88%e3%83%aa%e3%82%92%e9%81%8e%e5%8e%bb%e3%81%ae%e3%82%b3%e3%83%9f%e3%83%83%e3%83%88%e6%99%82%e7%82%b9%e3%81%be%e3%81%a7%e3%83%aa%e3%82%bb%e3%83%83%e3%83%88%e3%81%99%e3%82%8b)
- [まとめ](#%e3%81%be%e3%81%a8%e3%82%81)

# `git` リポジトリを作成する
- `git`管理を行うディレクトリとして、`git_test`ディレクトリを作成し、移動します。
- **`cmd, bash`**
  ```bash
  makedir git_test
  cd git_test
  ```
- `git init`コマンドを実行すると、`git`リポジトリが生成されます。
- **`cmd, bash`**
    ```bash
    git init
    ```
- `git`リポジトリの実体である`.git`ディレクトリが作成されていることが確認できます。
- これでリポジトリの作成は完了です。

# `git` でファイルの管理を行う
- `myfile.txt`という空のファイルを作成します。
  - **`cmd, bash`**
    ```bash
    # bash
    touch myfile.txt

    # cmd
    copy nul > myfile.txt
    ```
  - この時点では`git`リポジトリにローカルの変更は反映されていません。
    - ファイルを追加し、コミット（後述）を行うことでリポジトリに変更を反映できます。
- `git add` コマンドを利用して、`git_test`ディレクトリ以下のファイルをリポジトリに登録します。
  - **`cmd, bash`**
    ```bash
    git add .
    ```
  - `[OPTIONAL] git status` コマンドを実行すると、追加されるファイルが表示されます。
- `git commit` コマンドを利用して、リポジトリに変更を反映します。
  - **`cmd, bash`**
    ```bash
    git commit -m "my first commit."
    ```
- `[OPTIONAL]` `git log` コマンドを利用して、変更（コミット）履歴を確認できます。
  - **`cmd, bash`**
    ```bash
    git log
    ```
  - `my first commit` がログに残っていることが確認できます。
- `[OPTIONAL]` 現在のリポジトリを複製して、内容を確認してみます。
  - `git clone` コマンドを利用してリポジトリを復元します。
  - **`cmd, bash`**
    ```bash
    mkdir clone
    cd clone
    git clone ../../git_test
    cd ..
    ```
  - 作成した `clone` ディレクトリの下に、コミット時点での `git_test` 全体がクローンされていることが確認できます。
  - この手順を実行した場合、作成した `clone` ディレクトリは削除しておきます。

# ファイルの変更をステージングする
- ファイル内容に変更を加えて、リポジトリに変更を反映してみます。
  - **`cmd, bash`**
    ```bash
    echo "changed text." > myfile.txt
    git add .
    ```
  - 上記のように、`add` を改めて行う必要があります。
    - `git` が管理するファイルは、まず `add` によってステージングされる必要があるためです。
    - ステージングされた変更は `commit` コマンドによって確定されます。
      - コミットを行う前に、ここで `git` で管理しないファイルの設定を試してみます。

# `.gitignore` の追加
- `.gitignore` および `mysecret.txt` という空のファイルを作成します。
- `.gitignore` には `mysecret.*` という内容を記述します。
  - **`cmd, bash`**
    ```bash
    # bash
    touch mysecret.txt
    touch .gitignore
    echo "mysecret.*" > .gitignore

    # cmd
    copy nul > mysecret.txt
    copy nul > .gitignore
    echo "mysecret.*" > .gitignore
    ```
- `git add .` を実行し、`git status` でステージングされたファイルを確認します。
- `.gitignore` が追加されますが、`mysecret.txt` ファイルはステージングされていないことが確認できます。
  - 手元で利用しているAPIキーや、データベースの接続情報などのファイルを指定しておくと便利です。
  - なお、`git`は仕組み上あらゆる変更履歴がコミットとして残り、トレース可能となります。
    - つまり、これらの秘密情報を一度でもコミットしてしまった場合、リポジトリを再作成するか、`github`などで外部公開を行わないよう注意が必要です。

# リポジトリにステージングされた変更をコミットする
- `git` リポジトリに変更を正式に反映します。
  - **`cmd, bash`**
    ```bash
    git commit -am "edited myfile.txt"
    ```
  - コミットメッセージには、どのような変更を行ったのか概要を記載します。
    - 日本語のコミットメッセージを書くこともできます。
  - `-a` オプションを付与することで、`git add` と同様の処理を行うことができます。

# リポジトリを過去のコミット時点までリセットする
- `git log` コマンドを実行し、過去のコミットのログを確認します。
- `my first commit` コミットのコミットIDの内容をコピーします。
- `git reset --hard commitid` の形式で、`commitid` の箇所をコピーしたコミットIDに置き換えます。
- 実行すると、`my first commit` の時点までリポジトリの状態がロールバックします。

# まとめ
- ローカル環境でのリポジトリの作成から、コミットの操作まで行いました。
- 次の章では、`github` を用いたリモートリポジトリとの連携を行います。
